package com.tibtech.nifi.processors.elasticsearch;

import groovy.lang.Closure;
import groovy.lang.DelegatesTo;
import java.lang.String;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

public final class PutElasticsearchHttpRecord {
  /**
   * The component type name.
   */
  public static final String COMPONENT_TYPE = "org.apache.nifi.processors.elasticsearch.PutElasticsearchHttpRecord";

  /**
   * Elasticsearch URL which will be connected to, including scheme (http, e.g.), host, and port. The default port for the REST API is 9200.
   */
  public static final String ELASTICSEARCH_HTTP_URL_PROPERTY = "elasticsearch-http-url";

  /**
   * The SSL Context Service used to provide client certificate information for TLS/SSL connections. This service only applies if the Elasticsearch endpoint(s) have been secured with TLS/SSL.
   */
  public static final String SSL_CONTEXT_SERVICE_PROPERTY = "SSL Context Service";

  /**
   * Username to access the Elasticsearch cluster
   */
  public static final String USERNAME_PROPERTY = "Username";

  /**
   * Password to access the Elasticsearch cluster
   */
  public static final String PASSWORD_PROPERTY = "Password";

  /**
   * Max wait time for the connection to the Elasticsearch REST API.
   */
  public static final String ELASTICSEARCH_HTTP_CONNECT_TIMEOUT_PROPERTY = "elasticsearch-http-connect-timeout";

  /**
   * Max wait time for a response from the Elasticsearch REST API.
   */
  public static final String ELASTICSEARCH_HTTP_RESPONSE_TIMEOUT_PROPERTY = "elasticsearch-http-response-timeout";

  /**
   * Specifies the Proxy Configuration Controller Service to proxy network requests. If set, it supersedes proxy settings configured per component. Supported proxies: HTTP + AuthN, SOCKS
   */
  public static final String PROXY_CONFIGURATION_SERVICE_PROPERTY = "proxy-configuration-service";

  /**
   * The fully qualified hostname or IP address of the proxy server
   */
  public static final String ELASTICSEARCH_HTTP_PROXY_HOST_PROPERTY = "elasticsearch-http-proxy-host";

  /**
   * The port of the proxy server
   */
  public static final String ELASTICSEARCH_HTTP_PROXY_PORT_PROPERTY = "elasticsearch-http-proxy-port";

  /**
   * Proxy Username
   */
  public static final String PROXY_USERNAME_PROPERTY = "proxy-username";

  /**
   * Proxy Password
   */
  public static final String PROXY_PASSWORD_PROPERTY = "proxy-password";

  /**
   * Specifies the Controller Service to use for parsing incoming data and determining the data's schema.
   */
  public static final String PUT_ES_RECORD_RECORD_READER_PROPERTY = "put-es-record-record-reader";

  /**
   * A RecordPath pointing to a field in the record(s) that contains the identifier for the document. If the Index Operation is "index", this property may be left empty or evaluate to an empty value, in which case the document's identifier will be auto-generated by Elasticsearch. For all other Index Operations, the field's value must be non-empty.
   */
  public static final String PUT_ES_RECORD_ID_PATH_PROPERTY = "put-es-record-id-path";

  /**
   * The name of the index to insert into
   */
  public static final String PUT_ES_RECORD_INDEX_PROPERTY = "put-es-record-index";

  /**
   * The type of this document (used by Elasticsearch for indexing and searching)
   */
  public static final String PUT_ES_RECORD_TYPE_PROPERTY = "put-es-record-type";

  /**
   * The type of the operation used to index (index, update, upsert, delete)
   */
  public static final String PUT_ES_RECORD_INDEX_OP_PROPERTY = "put-es-record-index-op";

  /**
   * Specifies how the writer should handle a null field
   */
  public static final String SUPPRESS_NULLS_PROPERTY = "suppress-nulls";

  private final Map<String, String> properties;

  public PutElasticsearchHttpRecord() {
    this.properties = new HashMap<>();
  }

  public PutElasticsearchHttpRecord(final Map<String, String> properties) {
    this.properties = new HashMap<>(properties);
  }

  /**
   * Elasticsearch URL which will be connected to, including scheme (http, e.g.), host, and port. The default port for the REST API is 9200.
   */
  public final String getElasticsearchHttpUrl() {
    return properties.get(ELASTICSEARCH_HTTP_URL_PROPERTY);
  }

  /**
   * Elasticsearch URL which will be connected to, including scheme (http, e.g.), host, and port. The default port for the REST API is 9200.
   */
  public final PutElasticsearchHttpRecord setElasticsearchHttpUrl(
      final String elasticsearchHttpUrl) {
    properties.put(ELASTICSEARCH_HTTP_URL_PROPERTY, elasticsearchHttpUrl);
    return this;
  }

  /**
   * Elasticsearch URL which will be connected to, including scheme (http, e.g.), host, and port. The default port for the REST API is 9200.
   */
  public final PutElasticsearchHttpRecord removeElasticsearchHttpUrl() {
    properties.remove(ELASTICSEARCH_HTTP_URL_PROPERTY);
    return this;
  }

  /**
   * The SSL Context Service used to provide client certificate information for TLS/SSL connections. This service only applies if the Elasticsearch endpoint(s) have been secured with TLS/SSL.
   */
  public final String getSslContextService() {
    return properties.get(SSL_CONTEXT_SERVICE_PROPERTY);
  }

  /**
   * The SSL Context Service used to provide client certificate information for TLS/SSL connections. This service only applies if the Elasticsearch endpoint(s) have been secured with TLS/SSL.
   */
  public final PutElasticsearchHttpRecord setSslContextService(final String sslContextService) {
    properties.put(SSL_CONTEXT_SERVICE_PROPERTY, sslContextService);
    return this;
  }

  /**
   * The SSL Context Service used to provide client certificate information for TLS/SSL connections. This service only applies if the Elasticsearch endpoint(s) have been secured with TLS/SSL.
   */
  public final PutElasticsearchHttpRecord removeSslContextService() {
    properties.remove(SSL_CONTEXT_SERVICE_PROPERTY);
    return this;
  }

  /**
   * Username to access the Elasticsearch cluster
   */
  public final String getUsername() {
    return properties.get(USERNAME_PROPERTY);
  }

  /**
   * Username to access the Elasticsearch cluster
   */
  public final PutElasticsearchHttpRecord setUsername(final String username) {
    properties.put(USERNAME_PROPERTY, username);
    return this;
  }

  /**
   * Username to access the Elasticsearch cluster
   */
  public final PutElasticsearchHttpRecord removeUsername() {
    properties.remove(USERNAME_PROPERTY);
    return this;
  }

  /**
   * Password to access the Elasticsearch cluster
   */
  public final String getPassword() {
    return properties.get(PASSWORD_PROPERTY);
  }

  /**
   * Password to access the Elasticsearch cluster
   */
  public final PutElasticsearchHttpRecord setPassword(final String password) {
    properties.put(PASSWORD_PROPERTY, password);
    return this;
  }

  /**
   * Password to access the Elasticsearch cluster
   */
  public final PutElasticsearchHttpRecord removePassword() {
    properties.remove(PASSWORD_PROPERTY);
    return this;
  }

  /**
   * Max wait time for the connection to the Elasticsearch REST API.
   */
  public final String getElasticsearchHttpConnectTimeout() {
    return properties.get(ELASTICSEARCH_HTTP_CONNECT_TIMEOUT_PROPERTY);
  }

  /**
   * Max wait time for the connection to the Elasticsearch REST API.
   */
  public final PutElasticsearchHttpRecord setElasticsearchHttpConnectTimeout(
      final String elasticsearchHttpConnectTimeout) {
    properties.put(ELASTICSEARCH_HTTP_CONNECT_TIMEOUT_PROPERTY, elasticsearchHttpConnectTimeout);
    return this;
  }

  /**
   * Max wait time for the connection to the Elasticsearch REST API.
   */
  public final PutElasticsearchHttpRecord removeElasticsearchHttpConnectTimeout() {
    properties.remove(ELASTICSEARCH_HTTP_CONNECT_TIMEOUT_PROPERTY);
    return this;
  }

  /**
   * Max wait time for a response from the Elasticsearch REST API.
   */
  public final String getElasticsearchHttpResponseTimeout() {
    return properties.get(ELASTICSEARCH_HTTP_RESPONSE_TIMEOUT_PROPERTY);
  }

  /**
   * Max wait time for a response from the Elasticsearch REST API.
   */
  public final PutElasticsearchHttpRecord setElasticsearchHttpResponseTimeout(
      final String elasticsearchHttpResponseTimeout) {
    properties.put(ELASTICSEARCH_HTTP_RESPONSE_TIMEOUT_PROPERTY, elasticsearchHttpResponseTimeout);
    return this;
  }

  /**
   * Max wait time for a response from the Elasticsearch REST API.
   */
  public final PutElasticsearchHttpRecord removeElasticsearchHttpResponseTimeout() {
    properties.remove(ELASTICSEARCH_HTTP_RESPONSE_TIMEOUT_PROPERTY);
    return this;
  }

  /**
   * Specifies the Proxy Configuration Controller Service to proxy network requests. If set, it supersedes proxy settings configured per component. Supported proxies: HTTP + AuthN, SOCKS
   */
  public final String getProxyConfigurationService() {
    return properties.get(PROXY_CONFIGURATION_SERVICE_PROPERTY);
  }

  /**
   * Specifies the Proxy Configuration Controller Service to proxy network requests. If set, it supersedes proxy settings configured per component. Supported proxies: HTTP + AuthN, SOCKS
   */
  public final PutElasticsearchHttpRecord setProxyConfigurationService(
      final String proxyConfigurationService) {
    properties.put(PROXY_CONFIGURATION_SERVICE_PROPERTY, proxyConfigurationService);
    return this;
  }

  /**
   * Specifies the Proxy Configuration Controller Service to proxy network requests. If set, it supersedes proxy settings configured per component. Supported proxies: HTTP + AuthN, SOCKS
   */
  public final PutElasticsearchHttpRecord removeProxyConfigurationService() {
    properties.remove(PROXY_CONFIGURATION_SERVICE_PROPERTY);
    return this;
  }

  /**
   * The fully qualified hostname or IP address of the proxy server
   */
  public final String getElasticsearchHttpProxyHost() {
    return properties.get(ELASTICSEARCH_HTTP_PROXY_HOST_PROPERTY);
  }

  /**
   * The fully qualified hostname or IP address of the proxy server
   */
  public final PutElasticsearchHttpRecord setElasticsearchHttpProxyHost(
      final String elasticsearchHttpProxyHost) {
    properties.put(ELASTICSEARCH_HTTP_PROXY_HOST_PROPERTY, elasticsearchHttpProxyHost);
    return this;
  }

  /**
   * The fully qualified hostname or IP address of the proxy server
   */
  public final PutElasticsearchHttpRecord removeElasticsearchHttpProxyHost() {
    properties.remove(ELASTICSEARCH_HTTP_PROXY_HOST_PROPERTY);
    return this;
  }

  /**
   * The port of the proxy server
   */
  public final String getElasticsearchHttpProxyPort() {
    return properties.get(ELASTICSEARCH_HTTP_PROXY_PORT_PROPERTY);
  }

  /**
   * The port of the proxy server
   */
  public final PutElasticsearchHttpRecord setElasticsearchHttpProxyPort(
      final String elasticsearchHttpProxyPort) {
    properties.put(ELASTICSEARCH_HTTP_PROXY_PORT_PROPERTY, elasticsearchHttpProxyPort);
    return this;
  }

  /**
   * The port of the proxy server
   */
  public final PutElasticsearchHttpRecord removeElasticsearchHttpProxyPort() {
    properties.remove(ELASTICSEARCH_HTTP_PROXY_PORT_PROPERTY);
    return this;
  }

  /**
   * Proxy Username
   */
  public final String getProxyUsername() {
    return properties.get(PROXY_USERNAME_PROPERTY);
  }

  /**
   * Proxy Username
   */
  public final PutElasticsearchHttpRecord setProxyUsername(final String proxyUsername) {
    properties.put(PROXY_USERNAME_PROPERTY, proxyUsername);
    return this;
  }

  /**
   * Proxy Username
   */
  public final PutElasticsearchHttpRecord removeProxyUsername() {
    properties.remove(PROXY_USERNAME_PROPERTY);
    return this;
  }

  /**
   * Proxy Password
   */
  public final String getProxyPassword() {
    return properties.get(PROXY_PASSWORD_PROPERTY);
  }

  /**
   * Proxy Password
   */
  public final PutElasticsearchHttpRecord setProxyPassword(final String proxyPassword) {
    properties.put(PROXY_PASSWORD_PROPERTY, proxyPassword);
    return this;
  }

  /**
   * Proxy Password
   */
  public final PutElasticsearchHttpRecord removeProxyPassword() {
    properties.remove(PROXY_PASSWORD_PROPERTY);
    return this;
  }

  /**
   * Specifies the Controller Service to use for parsing incoming data and determining the data's schema.
   */
  public final String getPutEsRecordRecordReader() {
    return properties.get(PUT_ES_RECORD_RECORD_READER_PROPERTY);
  }

  /**
   * Specifies the Controller Service to use for parsing incoming data and determining the data's schema.
   */
  public final PutElasticsearchHttpRecord setPutEsRecordRecordReader(
      final String putEsRecordRecordReader) {
    properties.put(PUT_ES_RECORD_RECORD_READER_PROPERTY, putEsRecordRecordReader);
    return this;
  }

  /**
   * Specifies the Controller Service to use for parsing incoming data and determining the data's schema.
   */
  public final PutElasticsearchHttpRecord removePutEsRecordRecordReader() {
    properties.remove(PUT_ES_RECORD_RECORD_READER_PROPERTY);
    return this;
  }

  /**
   * A RecordPath pointing to a field in the record(s) that contains the identifier for the document. If the Index Operation is "index", this property may be left empty or evaluate to an empty value, in which case the document's identifier will be auto-generated by Elasticsearch. For all other Index Operations, the field's value must be non-empty.
   */
  public final String getPutEsRecordIdPath() {
    return properties.get(PUT_ES_RECORD_ID_PATH_PROPERTY);
  }

  /**
   * A RecordPath pointing to a field in the record(s) that contains the identifier for the document. If the Index Operation is "index", this property may be left empty or evaluate to an empty value, in which case the document's identifier will be auto-generated by Elasticsearch. For all other Index Operations, the field's value must be non-empty.
   */
  public final PutElasticsearchHttpRecord setPutEsRecordIdPath(final String putEsRecordIdPath) {
    properties.put(PUT_ES_RECORD_ID_PATH_PROPERTY, putEsRecordIdPath);
    return this;
  }

  /**
   * A RecordPath pointing to a field in the record(s) that contains the identifier for the document. If the Index Operation is "index", this property may be left empty or evaluate to an empty value, in which case the document's identifier will be auto-generated by Elasticsearch. For all other Index Operations, the field's value must be non-empty.
   */
  public final PutElasticsearchHttpRecord removePutEsRecordIdPath() {
    properties.remove(PUT_ES_RECORD_ID_PATH_PROPERTY);
    return this;
  }

  /**
   * The name of the index to insert into
   */
  public final String getPutEsRecordIndex() {
    return properties.get(PUT_ES_RECORD_INDEX_PROPERTY);
  }

  /**
   * The name of the index to insert into
   */
  public final PutElasticsearchHttpRecord setPutEsRecordIndex(final String putEsRecordIndex) {
    properties.put(PUT_ES_RECORD_INDEX_PROPERTY, putEsRecordIndex);
    return this;
  }

  /**
   * The name of the index to insert into
   */
  public final PutElasticsearchHttpRecord removePutEsRecordIndex() {
    properties.remove(PUT_ES_RECORD_INDEX_PROPERTY);
    return this;
  }

  /**
   * The type of this document (used by Elasticsearch for indexing and searching)
   */
  public final String getPutEsRecordType() {
    return properties.get(PUT_ES_RECORD_TYPE_PROPERTY);
  }

  /**
   * The type of this document (used by Elasticsearch for indexing and searching)
   */
  public final PutElasticsearchHttpRecord setPutEsRecordType(final String putEsRecordType) {
    properties.put(PUT_ES_RECORD_TYPE_PROPERTY, putEsRecordType);
    return this;
  }

  /**
   * The type of this document (used by Elasticsearch for indexing and searching)
   */
  public final PutElasticsearchHttpRecord removePutEsRecordType() {
    properties.remove(PUT_ES_RECORD_TYPE_PROPERTY);
    return this;
  }

  /**
   * The type of the operation used to index (index, update, upsert, delete)
   */
  public final String getPutEsRecordIndexOp() {
    return properties.get(PUT_ES_RECORD_INDEX_OP_PROPERTY);
  }

  /**
   * The type of the operation used to index (index, update, upsert, delete)
   */
  public final PutElasticsearchHttpRecord setPutEsRecordIndexOp(final String putEsRecordIndexOp) {
    properties.put(PUT_ES_RECORD_INDEX_OP_PROPERTY, putEsRecordIndexOp);
    return this;
  }

  /**
   * The type of the operation used to index (index, update, upsert, delete)
   */
  public final PutElasticsearchHttpRecord removePutEsRecordIndexOp() {
    properties.remove(PUT_ES_RECORD_INDEX_OP_PROPERTY);
    return this;
  }

  /**
   * Specifies how the writer should handle a null field
   */
  public final String getSuppressNulls() {
    return properties.get(SUPPRESS_NULLS_PROPERTY);
  }

  /**
   * Specifies how the writer should handle a null field
   */
  public final PutElasticsearchHttpRecord setSuppressNulls(final String suppressNulls) {
    properties.put(SUPPRESS_NULLS_PROPERTY, suppressNulls);
    return this;
  }

  /**
   * Specifies how the writer should handle a null field
   */
  public final PutElasticsearchHttpRecord removeSuppressNulls() {
    properties.remove(SUPPRESS_NULLS_PROPERTY);
    return this;
  }

  public final String getDynamicProperty(final String name) {
    return properties.get(name);
  }

  public final PutElasticsearchHttpRecord setDynamicProperty(final String name,
      final String value) {
    properties.put(name, value);
    return this;
  }

  public final PutElasticsearchHttpRecord removeDynamicProperty(final String name) {
    properties.remove(name);
    return this;
  }

  public final Map<String, String> build() {
    return properties;
  }

  public static final Map<String, String> build(
      final Function<PutElasticsearchHttpRecord, PutElasticsearchHttpRecord> configurator) {
    return configurator.apply(new PutElasticsearchHttpRecord()).build();
  }

  public static final Map<String, String> build(
      @DelegatesTo(strategy = Closure.DELEGATE_ONLY, value = PutElasticsearchHttpRecord.class) final Closure<PutElasticsearchHttpRecord> closure) {
    return build(c -> {
      final Closure<com.tibtech.nifi.processors.elasticsearch.PutElasticsearchHttpRecord> code = closure.rehydrate(c, com.tibtech.nifi.processors.elasticsearch.PutElasticsearchHttpRecord.class, com.tibtech.nifi.processors.elasticsearch.PutElasticsearchHttpRecord.class);
      code.setResolveStrategy(Closure.DELEGATE_ONLY);
      code.call();
      return c;
    } );
  }

  public static final Map<String, String> update(final Map<String, String> properties,
      final Function<PutElasticsearchHttpRecord, PutElasticsearchHttpRecord> configurator) {
    return configurator.apply(new PutElasticsearchHttpRecord(properties)).build();
  }

  public static final Map<String, String> update(final Map<String, String> properties,
      @DelegatesTo(strategy = Closure.DELEGATE_ONLY, value = PutElasticsearchHttpRecord.class) final Closure<PutElasticsearchHttpRecord> closure) {
    return update(properties, c -> {
      final Closure<com.tibtech.nifi.processors.elasticsearch.PutElasticsearchHttpRecord> code = closure.rehydrate(c, com.tibtech.nifi.processors.elasticsearch.PutElasticsearchHttpRecord.class, com.tibtech.nifi.processors.elasticsearch.PutElasticsearchHttpRecord.class);
      code.setResolveStrategy(Closure.DELEGATE_ONLY);
      code.call();
      return c;
    } );
  }
}
